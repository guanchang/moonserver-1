!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
AIRAPI_H	airapi.h	2;"	d
AIRAPI_H	sample/airapi.h	2;"	d
BufBlockPool	singleton_buff.hpp	/^typedef boost::singleton_pool<BufBlock_t, sizeof(BufBlock_t)> BufBlockPool;$/;"	t
BufBlock_t	singleton_buff.hpp	/^struct BufBlock_t {$/;"	s
BufHead_t	singleton_buff.hpp	/^struct BufHead_t {$/;"	s
BufPagePool	singleton_buff.hpp	/^typedef boost::singleton_pool<Page_t, PAGE_SIZE> BufPagePool;$/;"	t
CFLAGS	Makefile	/^CFLAGS = -O2 -I\/usr\/include\/python2.5$/;"	m
CLEAR_BLOCK	singleton_buff.hpp	15;"	d
CRASH_BLOCK	singleton_buff.hpp	13;"	d
CYCLE_WAIT_NANO_SEC	workthread.hpp	7;"	d
DATA_BLOCK	singleton_buff.hpp	12;"	d
FIN_BLOCK	singleton_buff.hpp	14;"	d
GLOBAL_DATA_HPP	global_data.hpp	2;"	d
HANDLER_H	handler.hpp	2;"	d
HandlerBase	handler.hpp	/^class HandlerBase {$/;"	c
LIBS	Makefile	/^LIBS = -ldl -lpthread -lboost_system -ggdb -rdynamic -lpython2.5$/;"	m
LOCK_HPP	lock.hpp	2;"	d
MutexLock	lock.cpp	/^MutexLock::MutexLock() {$/;"	f	class:MutexLock
MutexLock	lock.hpp	/^class MutexLock {$/;"	c
PAGE_SIZE	singleton_buff.hpp	10;"	d
PUSH_ERRMSG	workthread.hpp	9;"	d
Page_t	singleton_buff.hpp	/^struct Page_t {$/;"	s
QUEUE_HPP	queue.hpp	2;"	d
Queue	queue.cpp	/^Queue<T>::Queue(int size) {$/;"	f	class:Queue
Queue	queue.hpp	/^template <class T> class Queue {$/;"	c
REACTOR_H	reactor.hpp	2;"	d
Reactor	reactor.cpp	/^Reactor::Reactor() {$/;"	f	class:Reactor
Reactor	reactor.hpp	/^class Reactor$/;"	c
SEM_HPP	sem.hpp	2;"	d
SINGLETON_BUFF_HPP	singleton_buff.hpp	2;"	d
STATIC_LIB	Makefile	/^STATIC_LIB = \/usr\/local\/lib\/liblog4cplus.a$/;"	m
Sem	sem.cpp	/^Sem::Sem() {$/;"	f	class:Sem
Sem	sem.hpp	/^class Sem {$/;"	c
ServerConfig_t	airapi.h	/^struct ServerConfig_t {$/;"	s
Skinfo_t	airapi.h	/^struct Skinfo_t {$/;"	s
Skinfo_t	sample/airapi.h	/^struct Skinfo_t {$/;"	s
TCPACCEPT_HPP	tcpaccept.hpp	2;"	d
TCPSOCKETPOOL_HPP	tcpsocketpool.hpp	2;"	d
TCPSOCKET_HPP	tcpsocket.hpp	2;"	d
TEST_INTERFACE	sample/test_interface.h	2;"	d
TIMEOUT	main.cpp	26;"	d	file:
TcpAccept	tcpaccept.cpp	/^TcpAccept::TcpAccept(Reactor &reactor)$/;"	f	class:TcpAccept
TcpAccept	tcpaccept.hpp	/^class TcpAccept : public HandlerBase {$/;"	c
TcpSocket	tcpsocket.cpp	/^TcpSocket::TcpSocket(Reactor &reactor)$/;"	f	class:TcpSocket
TcpSocket	tcpsocket.hpp	/^class TcpSocket : public HandlerBase$/;"	c
TcpSocketPool	tcpsocketpool.cpp	/^TcpSocketPool::TcpSocketPool(){$/;"	f	class:TcpSocketPool
TcpSocketPool	tcpsocketpool.hpp	/^class TcpSocketPool {$/;"	c
Thread	workthread.hpp	/^} Thread;$/;"	t	typeref:struct:__anon1
WORK_THREAD_HPP	workthread.hpp	2;"	d
addfd	client/stress_test.cpp	/^void addfd(int epoll_fd, int fd) {$/;"	f
alloc_block	singleton_buff.cpp	/^BufBlock_t* alloc_block(uint32_t length) {$/;"	f
buf_head	singleton_buff.hpp	/^    BufHead_t buf_head;$/;"	m	struct:BufBlock_t
buf_type	singleton_buff.hpp	/^    uint32_t buf_type;$/;"	m	struct:BufHead_t
check_timeout	handler.hpp	/^    virtual void check_timeout() {};$/;"	f	class:HandlerBase
check_timeout	tcpsocket.cpp	/^void TcpSocket::check_timeout() {$/;"	f	class:TcpSocket
close_conn	client/stress_test.cpp	/^void close_conn(int epoll_fd, int sockfd) {$/;"	f
cmd	client/stress_test.cpp	/^    uint32_t cmd;$/;"	m	struct:header_t	file:
cmd	sample/test_interface.h	/^    uint32_t cmd;$/;"	m	struct:header_t
create	tcpsocketpool.cpp	/^TcpSocket* TcpSocketPool::create(Reactor &reactor) {$/;"	f	class:TcpSocketPool
create_work_thread	workthread.hpp	/^void create_work_thread(Reactor* reactor, int i) {$/;"	f
daemon_start	main.cpp	/^static void daemon_start()$/;"	f	file:
deps	Makefile	/^deps = $(patsubst %.cpp,%.d,$(dir))$/;"	m
dir	Makefile	/^dir = $(notdir $(src))$/;"	m
dll	global_data.cpp	/^dll_func_t dll;$/;"	v
dll_func_struct	airapi.h	/^typedef struct dll_func_struct {$/;"	s
dll_func_struct	sample/airapi.h	/^typedef struct dll_func_struct {$/;"	s
dll_func_t	airapi.h	/^} dll_func_t;$/;"	t	typeref:struct:dll_func_struct
dll_func_t	sample/airapi.h	/^} dll_func_t;$/;"	t	typeref:struct:dll_func_struct
fini	reactor.cpp	/^bool Reactor::fini() {$/;"	f	class:Reactor
free_block	singleton_buff.cpp	/^void free_block(BufBlock_t* block) {$/;"	f
front	queue.cpp	/^T Queue<T>::front() {$/;"	f	class:Queue
g_receive_lock	global_data.cpp	/^MutexLock g_receive_lock;$/;"	v
g_receive_queue	global_data.cpp	/^Queue<BufBlock_t*> g_receive_queue;  \/\/接受队列$/;"	v
g_receive_sem	global_data.cpp	/^Sem g_receive_sem;$/;"	v
g_send_lock	global_data.cpp	/^MutexLock g_send_lock;$/;"	v
g_send_queue	global_data.cpp	/^Queue<BufBlock_t*> g_send_queue;     \/\/发送队列$/;"	v
g_server_conf	global_data.cpp	/^ServerConfig_t  g_server_conf;$/;"	v
getConf	sample/conf.py	/^def getConf():$/;"	f
get_curtime	reactor.hpp	/^    inline time_t get_curtime() {return m_curtime;}$/;"	f	class:Reactor
get_handler	reactor.cpp	/^HandlerBase* Reactor::get_handler(int fd) {$/;"	f	class:Reactor
handle	airapi.h	/^    void  *handle;$/;"	m	struct:dll_func_struct
handle	sample/airapi.h	/^    void  *handle;$/;"	m	struct:dll_func_struct
handle_ctl	reactor.cpp	/^bool Reactor::handle_ctl(int fd, int op, uint32_t events_mask) {$/;"	f	class:Reactor
handle_error	tcpaccept.cpp	/^void TcpAccept::handle_error() {$/;"	f	class:TcpAccept
handle_error	tcpsocket.cpp	/^void TcpSocket::handle_error() {$/;"	f	class:TcpSocket
handle_events	reactor.cpp	/^void Reactor::handle_events(int timeout) {$/;"	f	class:Reactor
handle_fini	airapi.h	/^    int (*handle_fini) ();$/;"	m	struct:dll_func_struct
handle_fini	sample/test_interface.cpp	/^extern "C" int handle_fini() {$/;"	f
handle_init	airapi.h	/^    int (*handle_init) ();$/;"	m	struct:dll_func_struct
handle_init	sample/test_interface.cpp	/^extern "C" int handle_init() {$/;"	f
handle_input	airapi.h	/^    int (*handle_input) (const char*, int, const Skinfo_t*);$/;"	m	struct:dll_func_struct
handle_input	sample/airapi.h	/^    int (*handle_input) (const char*, int, const Skinfo_t*);$/;"	m	struct:dll_func_struct
handle_input	sample/test_interface.cpp	/^extern "C" int handle_input(const char* recv_buf, int recv_len, const Skinfo_t* skinfo) {$/;"	f
handle_input	tcpaccept.cpp	/^bool TcpAccept::handle_input() {$/;"	f	class:TcpAccept
handle_input	tcpsocket.cpp	/^bool TcpSocket::handle_input() {$/;"	f	class:TcpSocket
handle_output	tcpaccept.cpp	/^bool TcpAccept::handle_output() {$/;"	f	class:TcpAccept
handle_output	tcpsocket.cpp	/^bool TcpSocket::handle_output() {$/;"	f	class:TcpSocket
handle_process	airapi.h	/^    int (*handle_process) (const char*, int, char**, int*, const Skinfo_t*);$/;"	m	struct:dll_func_struct
handle_process	sample/airapi.h	/^    int (*handle_process) (const char*, int, char**, int*, const Skinfo_t*);$/;"	m	struct:dll_func_struct
handle_process	sample/test_interface.cpp	/^extern "C" int handle_process(const char* recv_buf, int recv_len, char** send_buf, int* send_len, const Skinfo_t* skinfo) {$/;"	f
handle_size	reactor.hpp	/^    inline int handle_size() {return m_size;}$/;"	f	class:Reactor
header_t	client/stress_test.cpp	/^struct header_t {$/;"	s	file:
header_t	sample/test_interface.h	/^struct header_t {$/;"	s
id	singleton_buff.hpp	/^    int id;$/;"	m	struct:BufHead_t
init	reactor.cpp	/^bool Reactor::init(int size) {$/;"	f	class:Reactor
init_log	main.cpp	/^static void init_log() {$/;"	f	file:
ip_str	airapi.h	/^    char* ip_str;$/;"	m	struct:ServerConfig_t
key	singleton_buff.hpp	/^    uint32_t key;$/;"	m	struct:BufHead_t
len	client/stress_test.cpp	/^    uint32_t len;$/;"	m	struct:header_t	file:
len	sample/test_interface.h	/^    uint32_t len;$/;"	m	struct:header_t
len	singleton_buff.hpp	/^    uint32_t len;$/;"	m	struct:BufHead_t
len2page_size	singleton_buff.cpp	/^inline uint32_t len2page_size(uint32_t length) {$/;"	f
load_conf_parameters	main.cpp	/^static int load_conf_parameters(ServerConfig_t& server_conf) {$/;"	f	file:
local_ip	airapi.h	/^    uint32_t local_ip;$/;"	m	struct:Skinfo_t
local_ip	sample/airapi.h	/^    uint32_t local_ip;$/;"	m	struct:Skinfo_t
local_port	airapi.h	/^    uint16_t local_port;$/;"	m	struct:Skinfo_t
local_port	sample/airapi.h	/^    uint16_t local_port;$/;"	m	struct:Skinfo_t
lock	lock.cpp	/^void MutexLock::lock() {$/;"	f	class:MutexLock
m_conn_timeout	tcpsocket.hpp	/^    uint32_t m_conn_timeout;$/;"	m	class:TcpSocket
m_curtime	reactor.hpp	/^    time_t m_curtime;$/;"	m	class:Reactor
m_fd	reactor.hpp	/^    int m_fd;$/;"	m	class:Reactor
m_fd	tcpaccept.hpp	/^    int m_fd;$/;"	m	class:TcpAccept
m_fd	tcpsocket.hpp	/^    int m_fd;$/;"	m	class:TcpSocket
m_front	queue.hpp	/^    int m_front;$/;"	m	class:Queue
m_handler_cnt	reactor.hpp	/^    int m_handler_cnt;$/;"	m	class:Reactor
m_handlers	reactor.hpp	/^    HandlerBase** m_handlers;$/;"	m	class:Reactor
m_id	reactor.hpp	/^    int m_id;$/;"	m	class:Reactor
m_id	tcpsocket.hpp	/^    int m_id;$/;"	m	class:TcpSocket
m_inited	reactor.hpp	/^    bool m_inited;$/;"	m	class:Reactor
m_ip	tcpaccept.hpp	/^    sockaddr_in m_ip;$/;"	m	class:TcpAccept
m_ip	tcpsocket.hpp	/^    sockaddr_in m_ip;$/;"	m	class:TcpSocket
m_last_time	tcpsocket.hpp	/^    uint32_t m_last_time;$/;"	m	class:TcpSocket
m_local_ip	tcpsocket.hpp	/^    sockaddr_in m_local_ip;$/;"	m	class:TcpSocket
m_mutex_lock	lock.hpp	/^    pthread_mutex_t m_mutex_lock;$/;"	m	class:MutexLock
m_oldtime	reactor.hpp	/^    time_t m_oldtime;$/;"	m	class:Reactor
m_qlist	queue.hpp	/^    T* m_qlist;$/;"	m	class:Queue
m_reactor	tcpaccept.hpp	/^    Reactor& m_reactor;$/;"	m	class:TcpAccept
m_reactor	tcpsocket.hpp	/^    Reactor& m_reactor;$/;"	m	class:TcpSocket
m_rear	queue.hpp	/^    int m_rear;$/;"	m	class:Queue
m_recvbuf	tcpsocket.hpp	/^    uint8_t* m_recvbuf;$/;"	m	class:TcpSocket
m_recvbuf_size	tcpsocket.hpp	/^    uint32_t m_recvbuf_size;$/;"	m	class:TcpSocket
m_recvpos	tcpsocket.hpp	/^    uint32_t m_recvpos;$/;"	m	class:TcpSocket
m_sem	sem.hpp	/^    sem_t m_sem;$/;"	m	class:Sem
m_sendbufs	tcpsocket.hpp	/^    Queue<BufBlock_t*> m_sendbufs;  \/\/接受队列$/;"	m	class:TcpSocket
m_sendpos	tcpsocket.hpp	/^    uint32_t m_sendpos;$/;"	m	class:TcpSocket
m_singleton	tcpsocketpool.cpp	/^TcpSocketPool TcpSocketPool::m_singleton;$/;"	m	class:TcpSocketPool	file:
m_singleton	tcpsocketpool.hpp	/^    static TcpSocketPool m_singleton;$/;"	m	class:TcpSocketPool
m_size	queue.hpp	/^    int m_size;$/;"	m	class:Queue
m_size	reactor.hpp	/^    int m_size;$/;"	m	class:Reactor
m_sk	tcpsocket.hpp	/^    Skinfo_t m_sk;$/;"	m	class:TcpSocket
m_socketPool	tcpsocketpool.hpp	/^    boost::object_pool<TcpSocket> m_socketPool;$/;"	m	class:TcpSocketPool
m_timeout	tcpaccept.hpp	/^    uint32_t m_timeout;$/;"	m	class:TcpAccept
main	client/stress_test.cpp	/^int main (int argc, char* argv[]) {$/;"	f
main	main.cpp	/^int main(int argc, char* argv[]) {$/;"	f
make_id	reactor.hpp	/^    inline int make_id() {return m_id++;}$/;"	f	class:Reactor
nDefaultQueueSize	queue.hpp	/^const int nDefaultQueueSize = 1<<23;$/;"	v
need_free_send_buf	airapi.h	/^    int need_free_send_buf;$/;"	m	struct:ServerConfig_t
obj	Makefile	/^obj = $(patsubst %.cpp,%.o,$(dir))$/;"	m
page_base	singleton_buff.hpp	/^    uint8_t *page_base;$/;"	m	struct:BufBlock_t
page_num	singleton_buff.hpp	/^    uint32_t page_num;$/;"	m	struct:BufBlock_t
pop_queue	queue.cpp	/^T Queue<T>::pop_queue() {$/;"	f	class:Queue
port	airapi.h	/^    int port;$/;"	m	struct:ServerConfig_t
post	sem.cpp	/^void Sem::post() {$/;"	f	class:Sem
push_buf	tcpaccept.cpp	/^bool TcpAccept::push_buf(BufBlock_t* block) {$/;"	f	class:TcpAccept
push_buf	tcpsocket.cpp	/^bool TcpSocket::push_buf(BufBlock_t* block) {$/;"	f	class:TcpSocket
push_queue	queue.cpp	/^int Queue<T>::push_queue(const T& item) {$/;"	f	class:Queue
read_once	client/stress_test.cpp	/^bool read_once(int socketfd, char* buffer, int len) {$/;"	f
recvtm	airapi.h	/^    time_t recvtm;$/;"	m	struct:Skinfo_t
recvtm	sample/airapi.h	/^    time_t recvtm;$/;"	m	struct:Skinfo_t
register_interface	main.cpp	/^static int register_interface(char* so_name) {$/;"	f	file:
remote_ip	airapi.h	/^    uint32_t remote_ip;$/;"	m	struct:Skinfo_t
remote_ip	sample/airapi.h	/^    uint32_t remote_ip;$/;"	m	struct:Skinfo_t
remote_port	airapi.h	/^    uint16_t remote_port;$/;"	m	struct:Skinfo_t
remote_port	sample/airapi.h	/^    uint16_t remote_port;$/;"	m	struct:Skinfo_t
remove	tcpsocketpool.cpp	/^void TcpSocketPool::remove(TcpSocket* socket)$/;"	f	class:TcpSocketPool
request	client/stress_test.cpp	/^static const char* request = "GET http:\/\/localhost";$/;"	v	file:
ret	client/stress_test.cpp	/^    uint32_t ret;$/;"	m	struct:header_t	file:
ret	sample/test_interface.h	/^    uint32_t ret;$/;"	m	struct:header_t
sendtm	airapi.h	/^    time_t sendtm;$/;"	m	struct:Skinfo_t
sendtm	sample/airapi.h	/^    time_t sendtm;$/;"	m	struct:Skinfo_t
seq	client/stress_test.cpp	/^    uint32_t seq;                                                                                                               $/;"	m	struct:header_t	file:
seq	sample/test_interface.h	/^    uint32_t seq;$/;"	m	struct:header_t
set_handler	reactor.cpp	/^bool Reactor::set_handler(int fd, HandlerBase* handler) {$/;"	f	class:Reactor
setnonblocking	client/stress_test.cpp	/^int setnonblocking(int fd) {$/;"	f
show_banner	main.cpp	/^static void show_banner()$/;"	f	file:
sigterm_handler	main.cpp	/^static void sigterm_handler(int signo) {$/;"	f	file:
size	queue.cpp	/^int Queue<T>::size() {$/;"	f	class:Queue
sk	singleton_buff.hpp	/^    Skinfo_t sk;$/;"	m	struct:BufHead_t
so_name	airapi.h	/^    char* so_name;$/;"	m	struct:ServerConfig_t
socket	airapi.h	/^    int socket;$/;"	m	struct:Skinfo_t
socket	sample/airapi.h	/^    int socket;$/;"	m	struct:Skinfo_t
src	Makefile	/^src = $(wildcard *.cpp)$/;"	m
start	tcpaccept.cpp	/^bool TcpAccept::start(sockaddr_in &ip, uint32_t time_out) {$/;"	f	class:TcpAccept
start	tcpsocket.cpp	/^bool TcpSocket::start(int fd, sockaddr_in &ip, sockaddr_in &local_ip, uint32_t conn_timeout) {$/;"	f	class:TcpSocket
start_conn	client/stress_test.cpp	/^void start_conn(int epoll_fd, int num, const char*ip, int port) {$/;"	f
stop	main.cpp	/^volatile bool stop = false;$/;"	v
thread_tid	workthread.hpp	/^    pthread_t thread_tid;$/;"	m	struct:__anon1
tptr	workthread.hpp	/^Thread* tptr; $/;"	v
uid	client/stress_test.cpp	/^    uint32_t uid;$/;"	m	struct:header_t	file:
uid	sample/test_interface.h	/^    uint32_t uid;$/;"	m	struct:header_t
unlock	lock.cpp	/^void MutexLock::unlock() {$/;"	f	class:MutexLock
wait	sem.cpp	/^void Sem::wait() {$/;"	f	class:Sem
work_num	airapi.h	/^    int work_num;$/;"	m	struct:ServerConfig_t
work_run	workthread.hpp	/^void* work_run(void* arg) {$/;"	f
write_nbytes	client/stress_test.cpp	/^bool write_nbytes(int sockfd, const char* buffer, int len) {$/;"	f
~HandlerBase	handler.hpp	/^    virtual ~HandlerBase() {}$/;"	f	class:HandlerBase
~MutexLock	lock.cpp	/^MutexLock::~MutexLock() {$/;"	f	class:MutexLock
~Queue	queue.cpp	/^Queue<T>::~Queue() {$/;"	f	class:Queue
~Reactor	reactor.cpp	/^Reactor::~Reactor() {$/;"	f	class:Reactor
~Sem	sem.cpp	/^Sem::~Sem() {$/;"	f	class:Sem
~TcpAccept	tcpaccept.cpp	/^TcpAccept::~TcpAccept() {$/;"	f	class:TcpAccept
~TcpSocket	tcpsocket.cpp	/^TcpSocket::~TcpSocket() {$/;"	f	class:TcpSocket
~TcpSocketPool	tcpsocketpool.cpp	/^TcpSocketPool::~TcpSocketPool(){$/;"	f	class:TcpSocketPool
